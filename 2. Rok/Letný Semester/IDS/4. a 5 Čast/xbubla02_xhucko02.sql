DROP TABLE student CASCADE CONSTRAINT;
DROP TABLE predmet CASCADE CONSTRAINT;
DROP TABLE skuska CASCADE CONSTRAINT;
DROP TABLE hodnotenie CASCADE CONSTRAINT;
DROP TABLE ucitel CASCADE CONSTRAINT;
DROP TABLE osoba CASCADE CONSTRAINT;
DROP TABLE termin CASCADE CONSTRAINT;
DROP TABLE zapisuje_sa CASCADE CONSTRAINT;
DROP TABLE prihlasuje_sa CASCADE CONSTRAINT;
DROP TABLE otazka CASCADE CONSTRAINT;
DROP TABLE vyucuje CASCADE CONSTRAINT;


CREATE TABLE skuska(
    ID_skuska NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ID_predmet VARCHAR(20) NOT NULL UNIQUE, --Foreign Key
    login_u_g VARCHAR(20) NOT NULL, --Foreign
    otvorenie_prihlasovania TIMESTAMP,
    zatvorenie_prihlasovania TIMESTAMP,
    max_pocet_studentov INTEGER NOT NULL,
    max_pocet_bodov INTEGER NOT NULL,
    min_pocet_bodov INTEGER NOT NULL,
    pocet_otazok INTEGER NOT NULL,
    zverejnenie NUMBER(1,0) NOT NULL,
    pocet_terminov INTEGER NOT NULL,
    typ_skusky VARCHAR(10) NOT NULL, --pol = polsemestralka, sem = semestralka
    
    CHECK (otvorenie_prihlasovania < zatvorenie_prihlasovania),
    CHECK (max_pocet_studentov >= 0),
    CHECK (max_pocet_bodov >= 0),
    CHECK (min_pocet_bodov >= 0),
    CHECK (pocet_otazok >= 0),
    CHECK ((typ_skusky = 'sem' AND pocet_terminov >= 3) OR (typ_skusky = 'pol' AND pocet_terminov >= 1))
);


CREATE TABLE osoba(
    login VARCHAR(20) PRIMARY KEY,
    meno VARCHAR(30) NOT NULL,
    heslo VARCHAR(30) NOT NULL,
    email VARCHAR(50) NOT NULL
);


CREATE TABLE student(
    login_s VARCHAR(20) PRIMARY KEY,
    rocnik INTEGER NOT NULL,
    
    CHECK (rocnik >= 1)
);



CREATE TABLE predmet(
    ID_predmet VARCHAR(20) PRIMARY KEY,
    login_u VARCHAR(20), --Foreign, garant
    zapocet NUMBER NOT NULL,

    CHECK (zapocet >= 0)
);


CREATE TABLE ucitel(
    login_u VARCHAR(20) PRIMARY KEY
);


CREATE TABLE hodnotenie(
    ID_hodnotenie NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    ID_termin NUMBER NOT NULL, --Foreign
    login_u VARCHAR(20) NOT NULL, --Foreign
    login_s VARCHAR(20)NOT NULL, --Foreign
    datum_hodnotenia TIMESTAMP NOT NULL,
    pocet_bodov NUMBER NOT NULL,
    bodovanie_otazok VARCHAR(50), --Pocty bodov za jednotlive otazky v tvare (5|10|12|1 ....)
    
    CHECK (pocet_bodov >= 0)
);


CREATE TABLE termin(
    ID_termin NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    ID_skuska NUMBER NOT NULL, --Foreign
    cas_konania TIMESTAMP NOT NULL
);


CREATE TABLE prihlasuje_sa(
    ID_termin NUMBER NOT NULL, --Foreign
    login_s VARCHAR(20) NOT NULL  --Foreign
);


CREATE TABLE zapisuje_sa(
    ID_predmet VARCHAR(20) NOT NULL, --Foreign
    login_s VARCHAR(20) NOT NULL,      --Foreign
    pocet_ziskanych_bodov NUMBER NOT NULL,
    
    CHECK (pocet_ziskanych_bodov >= 0)
);


CREATE TABLE otazka(
    ID_otazka NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    ID_skuska NUMBER NOT NULL, --Foreign
    zadanie VARCHAR(200)
);


CREATE TABLE vyucuje(
    ID_predmet VARCHAR(20) NOT NULL, --Foreign
    login_u VARCHAR(20) NOT NULL -- Foreign
); 


--Composite Keys:
ALTER TABLE vyucuje ADD CONSTRAINT pk_vyucuje PRIMARY KEY (ID_predmet, login_u);
ALTER TABLE zapisuje_sa ADD CONSTRAINT pk_zapisuje_sa PRIMARY KEY (ID_predmet, login_s);
ALTER TABLE prihlasuje_sa ADD CONSTRAINT pk_prihlasuje_sa PRIMARY KEY (ID_termin, login_s);


--Foreign Keys:
ALTER TABLE skuska ADD CONSTRAINT fk_ID_predmet FOREIGN KEY (ID_predmet) REFERENCES predmet(ID_predmet);
ALTER TABLE skuska ADD CONSTRAINT fk_login FOREIGN KEY (login_u_g) REFERENCES ucitel(login_u);

ALTER TABLE predmet ADD CONSTRAINT fk_login4 FOREIGN KEY (login_u) REFERENCES ucitel(login_u);
ALTER TABLE hodnotenie ADD CONSTRAINT fk_login5 FOREIGN KEY (login_u) REFERENCES ucitel(login_u);
ALTER TABLE hodnotenie ADD CONSTRAINT fk_login9 FOREIGN KEY (login_s, ID_termin) REFERENCES prihlasuje_sa(login_s, ID_termin);

ALTER TABLE termin ADD CONSTRAINT fk_ID_skuska FOREIGN KEY (ID_skuska) REFERENCES skuska(ID_skuska);

ALTER TABLE prihlasuje_sa ADD CONSTRAINT fk_ID_termin2 FOREIGN KEY (ID_termin) REFERENCES termin(ID_termin);
ALTER TABLE prihlasuje_sa ADD CONSTRAINT fk_login6 FOREIGN KEY (login_s) REFERENCES student(login_s);

ALTER TABLE zapisuje_sa ADD CONSTRAINT fk_ID_predmet2 FOREIGN KEY (ID_predmet) REFERENCES predmet(ID_predmet);
ALTER TABLE zapisuje_sa ADD CONSTRAINT fk_login7 FOREIGN KEY (login_s) REFERENCES student(login_s);

ALTER TABLE otazka ADD CONSTRAINT fk_ID_skuska2 FOREIGN KEY (ID_skuska) REFERENCES skuska(ID_skuska) ON DELETE CASCADE;

ALTER TABLE vyucuje ADD CONSTRAINT fk_ID_predmet3 FOREIGN KEY (ID_predmet) REFERENCES predmet(ID_predmet);
ALTER TABLE vyucuje ADD CONSTRAINT fk_login8 FOREIGN KEY (login_u) REFERENCES ucitel(login_u);

ALTER TABLE student ADD CONSTRAINT fk_login10 FOREIGN KEY (login_s) REFERENCES osoba(login);
ALTER TABLE ucitel ADD CONSTRAINT fk_login11 FOREIGN KEY (login_u) REFERENCES osoba(login);




--Trigger:
SET SERVEROUTPUT ON;

--Check login format
CREATE OR REPLACE TRIGGER check_login
	BEFORE INSERT OR UPDATE OF login ON osoba
	FOR EACH ROW
DECLARE
	login VARCHAR(20);
    surname  VARCHAR(30);
    sur_index NUMBER;
    test_login VARCHAR(30);
    num_of_people NUMBER;
    chr_value VARCHAR(5);
BEGIN
    dbms_output.enable;
    
	login := :NEW.login;
    sur_index := INSTR(TRIM(:NEW.meno), ' '); --Get start index of surname
    
    --If the INSTR function returned 0, then surname wanst given
    IF(sur_index = 0) THEN
        Raise_Application_Error (-20001, 'Priezvisko nebolo zadané!');
    END IF;
    
    surname := SUBSTR(TRIM(:NEW.meno), sur_index+1); --Get the surname

    --Login checking----------------------------------
    IF(LENGTH(surname) < 5) THEN
        --If length of  the surname is less than 5, append the whole surname to 'x'
        test_login := 'x' || surname;
        
        --Then get remaining characters from first name
        FOR i IN 1..5-LENGTH(surname)
        LOOP
            test_login := test_login || SUBSTR(TRIM(:NEW.meno), i, 1);
        END LOOP;
    ELSE
        --Else if its bigger than 5, get first 5 letters and append it to 'x' 
        test_login := 'x' || SUBSTR(TRIM(surname), 1, 5);
    END IF;
    
    test_login := LOWER(test_login);
    
    --Get the number of people with the same login (returns the number to give to new person)
    SELECT COUNT(*) INTO num_of_people
    FROM osoba
    WHERE SUBSTR(login, 1, 6) = test_login;
    
    IF(num_of_people < 10) THEN
        --If there are less than 10 people with the same login, just append the number to '0' (xexamp01...9)
        test_login := test_login || '0' || TO_CHAR(num_of_people);
        
    ELSIF(num_of_people < 100 AND num_of_people > 9) THEN
        --Else if there are less than 100 people but more that 9, append the whole number to the end of the login (xexamp10 .. 99)
        test_login := test_login || TO_CHAR(num_of_people);
    ELSE
        --Else there are more than 99 people with the same login
        num_of_people := num_of_people - 100; --Remove the excess so we start at 1
        
        --First character of login number
        IF(num_of_people < 260) THEN
            --If there are less than 260 people, divide it by 26 (26 letters in alphabet) and append it to login (xexamp0...9 a .. z)
            test_login := test_login || TO_CHAR(TRUNC(num_of_people / 26));
        ELSE
            --If there are more than 259 people
            IF(num_of_people > 935) THEN
                --If there are more than 935 people with the same login, that limit is being exceeded, dont add new person
                Raise_Application_Error (-20002, 'Poèet loginov presiahol kapacitu!');
            END IF;
            num_of_people := num_of_people - 260; --Remove the excess, so we start at 1
            
            test_login := test_login || CHR(TRUNC(num_of_people / 26) + 97); --Divide number of people by the number of letter in alphabet and add 97 (ascii value of 'a')
        END IF;
        
        --Second character of login number
        chr_value := CHR((num_of_people MOD 26) + 97); --Get letter of the alphabet
        
        dbms_output.put_line('Serus, ' || chr_value);
        test_login := test_login || chr_value; --Append it to login
    END IF;
    
    --compare login to test login
    IF(test_login != :NEW.login) THEN
            --If it doesnt match, error
        Raise_Application_Error (-20003, 'Login sa nezhoduje s oèakávaným!');
    END IF;
    ---------------------------------------------------
    
END check_login;
/
show errors


--Email checking---------------------------------------
CREATE OR REPLACE TRIGGER check_email
    BEFORE INSERT OR UPDATE OF login ON osoba
    FOR EACH ROW
DECLARE
    valid BOOLEAN;
BEGIN

    valid := REGEXP_LIKE(:NEW.email, '^([a-zA-z]|[0-9]|[!#$%&*+-\/=?^_`{|}~])+@([a-zA-Z]|[0-9]|[-])+\.[a-zA-Z]{2,4}$');
        
    IF(valid = false) THEN
        Raise_Application_Error (-20004, 'Zadaný email má nesprávny formát!');
    END IF;
    
END check_email;
/
show errors
 ---------------------------------------------------
 
 
 --Check if garant is crating exam------------------
CREATE OR REPLACE TRIGGER check_if_garant
    BEFORE INSERT OR UPDATE OF login_u_g ON skuska
    FOR EACH ROW
DECLARE
    cursor garant IS SELECT login_u FROM predmet WHERE login_u = :NEW.login_u_g AND ID_predmet = :NEW.ID_predmet;
    gar garant%ROWTYPE;
BEGIN
    OPEN garant;
    FETCH garant INTO gar;
    
    IF (garant%NOTFOUND) THEN
        Raise_Application_Error (-20005, 'Ucitel ' || :NEW.login_u_g || ' nie je garantom predmetu ' || :NEW.ID_predmet || '!');
    END IF;
    
END check_if_garant;
/
show errors
 ---------------------------------------------------


--Procedures:

--Po zadani ID skusky vypíse kolko pisomiek pripadlo na kolko ucitelov a informacie o jednotlivych uciteloch
CREATE OR REPLACE PROCEDURE pocet_pisomiek(id__skuska IN NUMBER)
IS
    cursor hodnotenia IS SELECT login_u FROM hodnotenie WHERE ID_termin IN (SELECT ID_termin FROM termin NATURAL JOIN skuska WHERE ID_skuska = id__skuska) ORDER BY login_u;
    ucitel_record osoba%ROWTYPE;
    hodnotenie hodnotenia%ROWTYPE;
    ucitel_log VARCHAR(20);
    ucitel_log_next VARCHAR(20);
    pocet_ucitelov NUMBER;
    pocet_pisomiek NUMBER;
BEGIN
    dbms_output.enable;
    OPEN hodnotenia;
    pocet_pisomiek := 0;
    pocet_ucitelov := 0;
    ucitel_log := 'DEF';
    
    LOOP
        FETCH hodnotenia into hodnotenie;
        EXIT WHEN hodnotenia%NOTFOUND;
        
        IF (hodnotenia%ROWCOUNT = 0) THEN
			RAISE NO_DATA_FOUND;
        END IF;
        
        pocet_pisomiek := pocet_pisomiek + 1;
    
        
        IF(ucitel_log != hodnotenie.login_u) THEN
            pocet_ucitelov := pocet_ucitelov + 1;
            ucitel_log := hodnotenie.login_u;
            
            SELECT * into ucitel_record FROM osoba WHERE login = ucitel_log;
            dbms_output.put_line('Meno ucitela: ' || ucitel_record.meno);
            dbms_output.put_line('Login ucitela: ' || ucitel_log);
            dbms_output.put_line('Email ucitela: ' || ucitel_record.email);
            dbms_output.put_line('');
        END IF;
        
    END LOOP;
    
    dbms_output.put_line('Celkovy pocet pisomiek: ' || pocet_pisomiek);
    dbms_output.put_line('Pocet ucitelov: ' || pocet_ucitelov);
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        dbms_output.put_line('Skuska s danym ID neexistuje alebo este nebola hodnotena!');
    WHEN OTHERS THEN
        dbms_output.put_line('Chyba procedury pocet_pisomiek!');
END;
/



--Po zadani loginu studenta, vypise informacie o nom, na ake predmety je zapisany a kolko z nich ma aktualne bodov
CREATE OR REPLACE PROCEDURE student_info(login_student IN VARCHAR)
IS
    cursor zapisane_pr IS SELECT * FROM zapisuje_sa WHERE login_s = login_student;
    zapisany_pr zapisane_pr%ROWTYPE;
    osoba_info osoba%ROWTYPE;
    student_rocnik student.rocnik%TYPE;
    pocet_zapisanych_pr NUMBER;
BEGIN
    dbms_output.enable;
    OPEN zapisane_pr;
    pocet_zapisanych_pr := 0;
    
    SELECT * into osoba_info FROM osoba WHERE login = login_student;
    SELECT rocnik into student_rocnik FROM student WHERE login_s = login_student;
    
    IF (osoba_info.login IS NULL OR student_rocnik IS NULL) THEN
			RAISE NO_DATA_FOUND;
    END IF;
    
    dbms_output.put_line('Meno studenta: ' || osoba_info.meno);
    dbms_output.put_line('Login studenta: ' || osoba_info.login);
    dbms_output.put_line('Email studenta: ' || osoba_info.email);
    dbms_output.put_line('Rocnik: ' || student_rocnik);
    dbms_output.put_line('');
    
    LOOP
        FETCH zapisane_pr into zapisany_pr;
        EXIT WHEN zapisane_pr%NOTFOUND;
        
        IF (zapisane_pr%ROWCOUNT = 0) THEN
			RAISE NO_DATA_FOUND;
        END IF;
        
        dbms_output.put_line('-------' || zapisany_pr.ID_predmet || '-------');
        dbms_output.put_line('Ziskane body: ' || zapisany_pr.pocet_ziskanych_bodov);
        dbms_output.put_line('');
        
    END LOOP;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        dbms_output.put_line('Student s danym loginom neexistuje alebo nema zapisane ziadne predmety!');
    WHEN OTHERS THEN
        dbms_output.put_line('Chyba procedury student_info!');
END;
/


--Insert test data:

--Predvedenie triggeru check_login
INSERT INTO osoba VALUES('xhomol00', 'Mato  Homola', 'kappa', 'mat.hom@debb.me');
INSERT INTO osoba VALUES('xhomol00', 'Jano  Homola', 'kappa', 'jan.hom@debb.me');
INSERT INTO osoba VALUES('xhomol02', 'Jano  Homola', 'kappa', 'jan.hom@debb.me');
INSERT INTO osoba VALUES('xhomol01', 'Jano  Homola', 'kappa', 'jan.hom@debb.me');
--------------------------------------------------------------------------------


--Predvedenie triggeru check_email
INSERT INTO osoba VALUES('xdisco00', 'Jozef Discorï', 'lul', 'igor1006enhytut.com');
INSERT INTO osoba VALUES('xdisco00', 'Jozef Discorï', 'lul', 'igor1006enhytut.');
INSERT INTO osoba VALUES('xdisco00', 'Jozef Discorï', 'lul', 'igor1006@enhytut.com');
-------------------------------------------------------------------------------------

INSERT INTO osoba VALUES('xsmith00', 'Ronald Smith', '123456', 'rsmith@debb.com');
INSERT INTO osoba VALUES('xmoody00', 'Augustus Moody', 'OMEGALUL', 'erik3791@sgisfg.com');
INSERT INTO osoba VALUES('xpotte00', 'Harry Potter', 'PeepoHappy', 'irenka933@debb.com');
INSERT INTO osoba VALUES('xpeter00', 'Laco Peter', '123', 'Laco@debb.com');
INSERT INTO osoba VALUES('xseker00', 'Palo Sekera', '132456', 'Palo@debb.com');
INSERT INTO osoba VALUES('xsekpa00', 'Palo Sek', '132456', 'Palo@debb.com');
INSERT INTO osoba VALUES('xbuklu00', 'Lubomir Buk', '132456', 'Lubo@debb.com');
INSERT INTO osoba VALUES('xtupyp00', 'Peter Tupy', '132456', 'tupo@debb.com');
INSERT INTO osoba VALUES('xkrasn00', 'Igor Krasny', '132456', 'igor@debb.com');
INSERT INTO osoba VALUES('xkrasn01', 'Ingrid Krasna', '132456', 'ingrid@debb.com');


INSERT INTO student VALUES('xhomol00', '1');
INSERT INTO student VALUES('xdisco00', '4');
INSERT INTO student VALUES('xpeter00', '2');
INSERT INTO student VALUES('xsmith00', '3');
INSERT INTO student VALUES('xbuklu00', '3');
INSERT INTO student VALUES('xseker00', '3');

INSERT INTO ucitel VALUES('xmoody00');
INSERT INTO ucitel VALUES('xpotte00');
INSERT INTO ucitel VALUES('xsekpa00');
INSERT INTO ucitel VALUES('xkrasn01');
INSERT INTO ucitel VALUES('xtupyp00');

INSERT INTO predmet VALUES('IFJ', 'xmoody00', '20');
INSERT INTO predmet VALUES('IUS', 'xpotte00', '30');
INSERT INTO predmet VALUES('IOS', 'xpotte00', '25');
INSERT INTO predmet VALUES('IPK', 'xsekpa00', '25');
INSERT INTO predmet VALUES('IZG', 'xkrasn01', '25');
INSERT INTO predmet VALUES('ITW', 'xtupyp00', '0');

INSERT INTO zapisuje_sa VALUES('IFJ', 'xhomol00', '0');
INSERT INTO zapisuje_sa VALUES('IFJ', 'xdisco00', '35');
INSERT INTO zapisuje_sa VALUES('IFJ', 'xpeter00', '15');
INSERT INTO zapisuje_sa VALUES('IFJ', 'xsmith00', '25');
INSERT INTO zapisuje_sa VALUES('IFJ', 'xbuklu00', '48');
INSERT INTO zapisuje_sa VALUES('IFJ', 'xseker00', '12');
INSERT INTO zapisuje_sa VALUES('IOS', 'xhomol00', '28');
INSERT INTO zapisuje_sa VALUES('IOS', 'xdisco00', '33');
INSERT INTO zapisuje_sa VALUES('IOS', 'xpeter00', '18');
INSERT INTO zapisuje_sa VALUES('IOS', 'xsmith00', '27');
INSERT INTO zapisuje_sa VALUES('IOS', 'xbuklu00', '29');
INSERT INTO zapisuje_sa VALUES('IOS', 'xseker00', '34');

INSERT INTO vyucuje VALUES('IFJ', 'xmoody00');
INSERT INTO vyucuje VALUES('IFJ', 'xpotte00');
INSERT INTO vyucuje VALUES('IFJ', 'xsekpa00');
INSERT INTO vyucuje VALUES('IOS', 'xkrasn01');
INSERT INTO vyucuje VALUES('IOS', 'xtupyp00');

INSERT INTO skuska VALUES('1', 'IFJ', 'xmoody00', '23-03-29 08:00:00', '23-03-31 15:00:00', '300', '50', '0', '2', '1', '3', 'sem');
INSERT INTO skuska VALUES('2', 'IOS', 'xpotte00', '23-04-29 08:00:00', '23-04-30 15:00:00', '200', '20', '0', '1', '1', '1', 'pol');

--Predvedenie triggeru check_if_garant
INSERT INTO skuska VALUES('3', 'IZG', 'xsekpa00', '23-04-29 08:00:00', '23-04-30 15:00:00', '200', '20', '0', '1', '1', '1', 'pol');
INSERT INTO skuska VALUES('3', 'IZG', 'xkrasn01', '23-04-29 08:00:00', '23-04-30 15:00:00', '200', '20', '0', '1', '1', '1', 'pol');
--------------------------------------------------------------

INSERT INTO termin VALUES('1', '1', '23-04-12 15:00:00');
INSERT INTO termin VALUES('2', '1', '23-04-15 15:00:00');
INSERT INTO termin VALUES('3', '1', '23-04-18 18:00:00');
INSERT INTO termin VALUES('4', '2', '23-01-18 15:00:00');

INSERT INTO prihlasuje_sa VALUES('1', 'xhomol00');
INSERT INTO prihlasuje_sa VALUES('1', 'xdisco00');
INSERT INTO prihlasuje_sa VALUES('1', 'xpeter00');
INSERT INTO prihlasuje_sa VALUES('2', 'xsmith00');
INSERT INTO prihlasuje_sa VALUES('2', 'xbuklu00');
INSERT INTO prihlasuje_sa VALUES('2', 'xseker00');
INSERT INTO prihlasuje_sa VALUES('3', 'xhomol00');
INSERT INTO prihlasuje_sa VALUES('3', 'xdisco00');
INSERT INTO prihlasuje_sa VALUES('3', 'xpeter00');
INSERT INTO prihlasuje_sa VALUES('4', 'xsmith00');
INSERT INTO prihlasuje_sa VALUES('4', 'xbuklu00');
INSERT INTO prihlasuje_sa VALUES('4', 'xseker00');

INSERT INTO otazka VALUES('1', '1', 'Nakresli na papier obdlznik.');
INSERT INTO otazka VALUES('2', '1', 'Spocitaj na prstoch 5 + 5.');
INSERT INTO otazka VALUES('3', '1', 'Spocitaj na prstoch 7 + 8.');
INSERT INTO otazka VALUES('4', '2', 'Nakresli ER diagram');

INSERT INTO hodnotenie VALUES('1', '1', 'xmoody00', 'xhomol00', '23-04-15 15:00:00', '50', '20|20|10');
INSERT INTO hodnotenie VALUES('2', '1', 'xpotte00', 'xdisco00', '23-04-15 15:10:00', '30', '10|11|9');
INSERT INTO hodnotenie VALUES('3', '1', 'xsekpa00', 'xpeter00', '23-04-15 15:20:00', '15', '7|5|8');
INSERT INTO hodnotenie VALUES('4', '2', 'xmoody00', 'xsmith00', '23-04-19 15:20:00', '48', '20|18|10');
INSERT INTO hodnotenie VALUES('5', '2', 'xmoody00', 'xbuklu00', '23-04-19 15:20:00', '20', '5|5|10');
INSERT INTO hodnotenie VALUES('6', '2', 'xpotte00', 'xseker00', '23-04-19 15:20:00', '25', '10|5|10');
INSERT INTO hodnotenie VALUES('7', '3', 'xsekpa00', 'xhomol00', '23-04-20 15:00:00', '30', '10|12|8');
INSERT INTO hodnotenie VALUES('8', '3', 'xsekpa00', 'xdisco00', '23-04-20 15:00:00', '33', '8|15|10');
INSERT INTO hodnotenie VALUES('9', '3', 'xsekpa00', 'xpeter00', '23-04-20 15:00:00', '35', '15|5|15');
INSERT INTO hodnotenie VALUES('10', '4', 'xkrasn01', 'xsmith00', '23-01-22 15:00:00', '20', NULL);
INSERT INTO hodnotenie VALUES('11', '4', 'xkrasn01', 'xbuklu00', '23-01-22 15:00:00', '10', NULL);
INSERT INTO hodnotenie VALUES('12', '4', 'xtupyp00', 'xseker00', '23-01-22 15:00:00', '13', NULL);


--SELECT:

--Spojenie cez 2 tabulky, zobrazi vsetkych ucitelov ktorý su garanti a akého predmetu
SELECT login_u, ID_predmet FROM ucitel NATURAL JOIN predmet ORDER BY login_u;


--Spojenie cez 2 tabulky, zobrazi studentov a nimi ziskane body z predmetov
SELECT login_s, ID_predmet, pocet_ziskanych_bodov FROM student NATURAL JOIN zapisuje_sa ORDER BY login_s;


--Spojenie cez 3 tabulky, zobrazi hodnotenie terminov pre jednolivych studentov      
SELECT login_s, ID_termin, cas_konania, pocet_bodov, bodovanie_otazok 
    FROM prihlasuje_sa NATURAL JOIN termin NATURAL JOIN hodnotenie ORDER BY login_s;
        
        
--Group By - Zobrazi pocet studentov zapisanych na jednotlive predmety
SELECT ID_predmet, COUNT(*) pocet_studentov FROM zapisuje_sa GROUP BY (ID_predmet);


--Group by - Zobrazi priemer bodov skúok z predmetov
SELECT skuska.ID_predmet, ROUND(AVG(pocet_bodov)) priemer_bodov 
    FROM skuska NATURAL JOIN termin NATURAL JOIN hodnotenie 
    GROUP BY skuska.ID_predmet
    ORDER BY priemer_bodov DESC;
    
    
--EXIST - Zobrazi predmety na ktoré sa nikto neprihlásil
SELECT ID_predmet FROM predmet 
    WHERE NOT EXISTS (SELECT * FROM zapisuje_sa WHERE predmet.ID_predmet = zapisuje_sa.ID_predmet);


--IN - Zobrazi studentov, ktorý splnili zápoèet a z ktorého predmetu
SELECT login_s, ID_predmet FROM zapisuje_sa WHERE (login_s, ID_predmet)
    IN (SELECT login_s, ID_predmet FROM zapisuje_sa NATURAL JOIN predmet 
            WHERE pocet_ziskanych_bodov >= zapocet) ORDER BY login_s;
            
            
--GRANT RIGHTS:
GRANT ALL ON skuska TO xhucko02;
GRANT ALL ON osoba TO xhucko02;
GRANT ALL ON student TO xhucko02;
GRANT ALL ON predmet TO xhucko02;
GRANT ALL ON ucitel TO xhucko02;
GRANT ALL ON hodnotenie TO xhucko02;
GRANT ALL ON termin TO xhucko02;
GRANT ALL ON prihlasuje_sa TO xhucko02;
GRANT ALL ON zapisuje_sa TO xhucko02;
GRANT ALL ON otazka TO xhucko02;
GRANT ALL ON vyucuje TO xhucko02;


GRANT EXECUTE ON pocet_pisomiek TO xhucko02;
GRANT EXECUTE ON student_info TO xhucko02;


--MATERIALIZED VIEW:
ALTER SESSION SET query_rewrite_enabled = true;
DROP MATERIALIZED VIEW studentiZapocet;

CREATE MATERIALIZED VIEW studentiZapocet 

CACHE 
REFRESH ON COMMIT
ENABLE QUERY REWRITE

--Zobrazi studentov ktory splnili zapocet
AS SELECT login_s, ID_predmet, pocet_ziskanych_bodov FROM zapisuje_sa NATURAL JOIN predmet WHERE pocet_ziskanych_bodov > zapocet ORDER BY login_s;

GRANT ALL ON studentiZapocet TO xhucko02;

SELECT * FROM studentiZapocet;
INSERT INTO zapisuje_sa VALUES('IUS', 'xpeter00', '50');
COMMIT;
SELECT * FROM studentiZapocet;


--PROCEDURES EXECS:
exec pocet_pisomiek(1);
exec student_info('xdisco00');


--EXPLAIN PLAN:
--DROP INDEX ter_idx;


EXPLAIN PLAN FOR 
SELECT skuska.ID_predmet, ROUND(AVG(pocet_bodov)) priemer_bodov 
    FROM skuska NATURAL JOIN termin NATURAL JOIN hodnotenie 
    GROUP BY skuska.ID_predmet
    ORDER BY priemer_bodov DESC;
    
SELECT * FROM TABLE(DBMS_XPLAN.display());

CREATE INDEX ter_idx ON termin(ID_skuska, ID_termin);

EXPLAIN PLAN FOR
SELECT /*+ INDEX(skuska sk_idx)*/ skuska.ID_predmet, ROUND(AVG(pocet_bodov)) priemer_bodov 
    FROM skuska NATURAL JOIN termin NATURAL JOIN hodnotenie 
    GROUP BY skuska.ID_predmet
    ORDER BY priemer_bodov DESC;

SELECT * FROM TABLE(DBMS_XPLAN.display());

